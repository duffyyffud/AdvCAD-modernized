# coding: utf-8

import os
import numpy as np
import logging
from collections import defaultdict

class PchReader:
    """
    Reader for .pch files with connectivity integrity checking.
    Designed to validate mesh files generated by advcad in test suite.
    """
    
    def __init__(self, pch_path, quiet=False):
        self.pch_path = pch_path
        self.nodes = []
        self.triangles = []
        self.num_nodes = 0
        self.num_triangles = 0
        self.quiet = quiet
        
        if not os.path.exists(pch_path):
            raise FileNotFoundError(f"PCH file not found: {pch_path}")
    
    def read(self):
        """Read and parse the .pch file"""
        with open(self.pch_path, 'r') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        
        if len(lines) < 2:
            raise ValueError("Invalid .pch file format: too few lines")
        
        # Read number of nodes
        self.num_nodes = int(lines[0])
        
        # Read node coordinates
        self.nodes = []
        for i in range(1, self.num_nodes + 1):
            if i >= len(lines):
                raise ValueError(f"Expected {self.num_nodes} nodes, but file ended at line {i}")
            coords = lines[i].split()
            if len(coords) != 3:
                raise ValueError(f"Node {i-1}: expected 3 coordinates, got {len(coords)}")
            self.nodes.append([float(x) for x in coords])
        
        # Read number of triangles
        triangle_start = self.num_nodes + 1
        if triangle_start >= len(lines):
            raise ValueError("No triangle data found in .pch file")
        
        self.num_triangles = int(lines[triangle_start])
        
        # Read triangle connectivity
        self.triangles = []
        for i in range(triangle_start + 1, triangle_start + 1 + self.num_triangles):
            if i >= len(lines):
                raise ValueError(f"Expected {self.num_triangles} triangles, but file ended at line {i}")
            triangle = lines[i].split()
            if len(triangle) != 3:
                raise ValueError(f"Triangle {i-triangle_start-1}: expected 3 nodes, got {len(triangle)}")
            self.triangles.append([int(x) for x in triangle])
    
    def check_integrity(self):
        """
        Check connectivity integrity - designed for test suite validation.
        Returns tuple: (is_valid, error_list, warnings_list)
        """
        errors = []
        warnings = []
        
        # Critical errors that indicate mesh generation failure
        for i, triangle in enumerate(self.triangles):
            for j, node_idx in enumerate(triangle):
                if node_idx < 0 or node_idx >= self.num_nodes:
                    errors.append(f"Triangle {i}: invalid node index {node_idx}")
        
        for i, triangle in enumerate(self.triangles):
            if len(set(triangle)) != 3:
                errors.append(f"Triangle {i}: degenerate triangle {triangle}")
        
        # Check for mixed triangles (Face 7 issue)
        for i, triangle in enumerate(self.triangles):
            # In AdvCAD, dummy points have negative IDs, real points have >= 0
            negative_count = sum(1 for idx in triangle if idx < 0)
            if 0 < negative_count < 3:
                errors.append(f"Triangle {i}: mixed triangle with real and dummy points {triangle}")
        
        # Warnings for mesh quality issues
        used_nodes = set()
        for triangle in self.triangles:
            used_nodes.update(triangle)
        
        isolated_count = self.num_nodes - len(used_nodes)
        if isolated_count > 0:
            warnings.append(f"Found {isolated_count} isolated nodes")
        
        # Check for zero-area triangles
        zero_area_count = 0
        for i, triangle in enumerate(self.triangles):
            if any(idx < 0 for idx in triangle):  # Skip triangles with dummy points
                continue
                
            p1 = np.array(self.nodes[triangle[0]])
            p2 = np.array(self.nodes[triangle[1]])
            p3 = np.array(self.nodes[triangle[2]])
            
            v1 = p2 - p1
            v2 = p3 - p1
            area = 0.5 * np.linalg.norm(np.cross(v1, v2))
            
            if area < 1e-12:
                zero_area_count += 1
        
        if zero_area_count > 0:
            warnings.append(f"Found {zero_area_count} zero-area triangles")
        
        return len(errors) == 0, errors, warnings
    
    def validate_for_tests(self):
        """
        Validation specifically for test suite.
        Returns: (success, message)
        """
        try:
            self.read()
            is_valid, errors, warnings = self.check_integrity()
            
            if not self.quiet:
                print(f"PCH validation: {os.path.basename(self.pch_path)}")
                print(f"  Nodes: {self.num_nodes}, Triangles: {self.num_triangles}")
            
            if not is_valid:
                error_msg = f"CONNECTIVITY ERRORS: {'; '.join(errors[:3])}"
                if not self.quiet:
                    print(f"  Status: FAILED - {error_msg}")
                return False, error_msg
            
            if warnings and not self.quiet:
                print(f"  Warnings: {'; '.join(warnings[:2])}")
            
            if not self.quiet:
                print(f"  Status: VALID")
            
            return True, "Valid mesh connectivity"
            
        except Exception as e:
            error_msg = f"Parse error: {str(e)}"
            if not self.quiet:
                print(f"  Status: FAILED - {error_msg}")
            return False, error_msg

def validate_pch_file(pch_path, quiet=False):
    """
    Convenience function for test suite integration.
    Returns: (success, message)
    """
    reader = PchReader(pch_path, quiet=quiet)
    return reader.validate_for_tests()

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print("Usage: python PchReader.py <pch_file>")
        sys.exit(1)
    
    pch_file = sys.argv[1]
    success, message = validate_pch_file(pch_file, quiet=False)
    
    if not success:
        print(f"Validation failed: {message}")
        sys.exit(1)
    else:
        print(f"Validation passed: {message}")
        sys.exit(0)